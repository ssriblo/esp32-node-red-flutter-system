import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:mqtt_client/mqtt_client.dart';
import 'package:mqtt_client/mqtt_server_client.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/services.dart';


/// ====== НАСТРОЙКИ ПОД ТВОЮ VM ======
const String kBrokerHost = '130.61.123.45'; // IP Oracle VM с Mosquitto
const int kBrokerPort = 1883;               // незашифрованный MQTT
const String kClientId  = 'flutter_client_01';

const String kTopicSensors = 'esp32/sensors'; // JSON: {"temp": 28.5, "hum": 60}
const String kTopicPidParams = 'node_red/pid_parameters'; // Тема для отправки PID-параметров

/// ====== МОДЕЛЬ ТОЧКИ ГРАФИКА ======
class TempPoint {
  final DateTime t;
  final double value;
  TempPoint(this.t, this.value);
}

/// ====== MQTT СЕРВИС ======
class MqttService {
  late MqttServerClient client;
  final void Function(Map<String, dynamic> json) onSensorJson;

  MqttService({
    required this.onSensorJson,
  }) {
    client = MqttServerClient(kBrokerHost, kClientId)
      ..port = kBrokerPort
      ..keepAlivePeriod = 30
      ..autoReconnect = true
      ..onConnected = _onConnected
      ..onDisconnected = _onDisconnected
      ..resubscribeOnAutoReconnect = true
      ..logging(on: false);
  }

  Future<void> connect() async {
    final connMess = MqttConnectMessage()
        .withClientIdentifier(kClientId)
        .startClean(); // без сохранённой сессии

    client.connectionMessage = connMess;

    try {
      await client.connect(); // без логина/пароля (allow_anonymous true)
    } catch (_) {
      client.disconnect();
      rethrow;
    }

    client.updates?.listen((events) {
      // events — список полученных сообщений за "тик"
      for (final e in events) {
        final recMess = e.payload as MqttPublishMessage;
        final topic = e.topic;
        final payload =
            MqttPublishPayload.bytesToStringAsString(recMess.payload.message);

        if (topic == kTopicSensors) {
          try {
            final jsonMap = jsonDecode(payload) as Map<String, dynamic>;
            onSensorJson(jsonMap);
          } catch (_) {
            // игнорируем битые payload'ы
          }
        }
      }
    });
  }

  void _onConnected() {
    client.subscribe(kTopicSensors, MqttQos.atMostOnce);
  }

  void _onDisconnected() {
    // можно показать тост/баннер в UI через колбэки, если нужно
  }

  void dispose() {
    client.disconnect();
  }

  void sendPidParameters(double p, double i, double d) {
    final pidData = {
      'p': p,
      'i': i,
      'd': d,
    };

    final message = jsonEncode(pidData);
    final builder = MqttClientPayloadBuilder();
    builder.addString(message);

    client.publishMessage(
      kTopicPidParams,
      MqttQos.atMostOnce,
      builder.payload!,
    );
  }
}

/// ====== ПРИЛОЖЕНИЕ ======
void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ESP32 Monitor',
      theme: ThemeData(
        colorSchemeSeed: Colors.indigo,
        useMaterial3: true,
      ),
      home: const DashboardPage(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class DashboardPage extends StatefulWidget {
  const DashboardPage({super.key});
  @override
  State<DashboardPage> createState() => _DashboardPageState();
}

class _DashboardPageState extends State<DashboardPage> {
  late final MqttService _mqtt;
  final List<TempPoint> _points = <TempPoint>[];
  double? _lastTemp;
  double? _lastHum;

  static const int _maxPoints = 300; // Максимум точек на графике

  final TextEditingController _pController = TextEditingController(text: '0.1');
  final TextEditingController _iController = TextEditingController(text: '0.1');
  final TextEditingController _dController = TextEditingController(text: '0.1');

  @override
  void initState() {
    super.initState();
    _mqtt = MqttService(
      onSensorJson: (json) {
        final now = DateTime.now();
        final temp = (json['temp'] as num?)?.toDouble();
        final hum  = (json['hum']  as num?)?.toDouble();
        if (temp != null) {
          setState(() {
            _lastTemp = temp;
            _points.add(TempPoint(now, temp));
            if (_points.length > _maxPoints) {
              _points.removeAt(0);
            }
          });
        }
        if (hum != null) {
          setState(() => _lastHum = hum);
        }
      },
    );

    _connectMqtt();
  }

  Future<void> _connectMqtt() async {
    try {
      await _mqtt.connect();
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('MQTT connect error: $e')),
        );
      }
    }
  }

  @override
  void dispose() {
    _mqtt.dispose();
    _pController.dispose();
    _iController.dispose();
    _dController.dispose();
    super.dispose();
  }

  Future<void> _sendPidParameters() async {
    final p = double.tryParse(_pController.text);
    final i = double.tryParse(_iController.text);
    final d = double.tryParse(_dController.text);

    if (p == null || i == null || d == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Invalid PID values')),
      );
      return;
    }

    _mqtt.sendPidParameters(p, i, d);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ESP32 — Temperature'),
        actions: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12),
            child: Row(
              children: [
                const Icon(Icons.thermostat),
                const SizedBox(width: 6),
                Text(_lastTemp != null ? '${_lastTemp!.toStringAsFixed(1)} °C' : '—'),
                const SizedBox(width: 16),
                const Icon(Icons.water_drop),
                const SizedBox(width: 6),
                Text(_lastHum != null ? '${_lastHum!.toStringAsFixed(0)} %' : '—'),
              ],
            ),
          )
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          _TempChart(points: _points),
          const SizedBox(height: 16),
          _PidControls(
            pController: _pController,
            iController: _iController,
            dController: _dController,
            onSend: _sendPidParameters,
          ),
          const SizedBox(height: 8),
          Text(
            'Broker: $kBrokerHost:$kBrokerPort • Topics: $kTopicSensors, $kTopicPidParams',
            textAlign: TextAlign.center,
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }
}


class _TempChart extends StatelessWidget {
  final List<TempPoint> points;
  const _TempChart({required this.points});

  @override
  Widget build(BuildContext context) {
    final spots = points
        .map((p) => FlSpot(p.t.millisecondsSinceEpoch.toDouble(), p.value))
        .toList();

    final minX = spots.isNotEmpty ? spots.first.x : 0.0;
    final maxX = spots.isNotEmpty ? spots.last.x : 0.0;
    final minY = spots.isNotEmpty
        ? spots.map((e) => e.y).reduce((a, b) => a < b ? a : b)
        : 0.0;
    final maxY = spots.isNotEmpty
        ? spots.map((e) => e.y).reduce((a, b) => a > b ? a : b)
        : 0.0;

    final yInterval = (maxY - minY) / 5 == 0 ? 1.0 : (maxY - minY) / 5;

    return Card(
      elevation: 1,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Temperature Chart'),
            const SizedBox(height: 8),
            FractionallySizedBox(
              alignment: Alignment.center,
              widthFactor: 0.8, // Устанавливаем ширину на 80%
              child: AspectRatio(
                aspectRatio: 1.7,
                child: LineChart(
                  LineChartData(
                    minX: minX,
                    maxX: maxX,
                    minY: minY - yInterval,  // добавляем отступ
                    maxY: maxY + yInterval,  // добавляем отступ
                    gridData: FlGridData(
                      show: true,
                      drawHorizontalLine: true,
                      horizontalInterval: yInterval,
                      getDrawingHorizontalLine: (value) => FlLine(
                        color: Colors.grey.withOpacity(0.5),
                        strokeWidth: 1,
                      ),
                    ),
                    titlesData: FlTitlesData(
                      topTitles: AxisTitles(
                        sideTitles: SideTitles(showTitles: false), // Отключаем подписи сверху
                      ),
                      rightTitles: AxisTitles(
                        sideTitles: SideTitles(showTitles: false), // Отключаем метки справа
                      ),
                      leftTitles: AxisTitles(
                        sideTitles: SideTitles(
                          showTitles: true,
                          interval: yInterval,
                          reservedSize: 40,  // оставляем место для текста
                          getTitlesWidget: (value, meta) {
                            // Форматируем значение с 2 знаками после запятой
                            final text = value.toStringAsFixed(2);
                            return SideTitleWidget(
                              axisSide: meta.axisSide,
                              child: Text(
                                text,
                                style: const TextStyle(fontSize: 10),
                              ),
                            );
                          },
                        ),
                      ),
                      bottomTitles: AxisTitles(
                        sideTitles: SideTitles(
                          showTitles: true,
                          reservedSize: 30,
                          interval: (maxX - minX) / 4 == 0 ? 1.0 : (maxX - minX) / 4,
                          getTitlesWidget: (value, meta) {
                            final dt = DateTime.fromMillisecondsSinceEpoch(value.toInt());
                            return Text(
                              '${dt.hour}:${dt.minute.toString().padLeft(2, '0')}',
                              style: TextStyle(fontSize: 10),
                            );
                          },
                        ),
                      ),
                    ),
                    borderData: FlBorderData(
                      show: true,
                      border: Border(
                        left: BorderSide(color: Colors.grey),
                        bottom: BorderSide(color: Colors.grey),
                        right: BorderSide(color: Colors.transparent),
                        top: BorderSide(color: Colors.transparent),
                      ),
                    ),
                    lineBarsData: [
                      LineChartBarData(
                        spots: spots,
                        isCurved: true,
                        color: Colors.blue,
                        dotData: FlDotData(show: false),    // Убираем точки
                        belowBarData: BarAreaData(show: false),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Виджет управления PID-параметрами с фиксированной шириной полей ввода.
class _PidControls extends StatelessWidget {
  final TextEditingController pController;
  final TextEditingController iController;
  final TextEditingController dController;
  final Future<void> Function() onSend;

  const _PidControls({
    required this.pController,
    required this.iController,
    required this.dController,
    required this.onSend,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 1,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('PID Parameters'),
            const SizedBox(height: 8),
            Row(
              children: [
                _buildPidField(label: 'P', controller: pController),
                const SizedBox(width: 8),
                _buildPidField(label: 'I', controller: iController),
                const SizedBox(width: 8),
                _buildPidField(label: 'D', controller: dController),
                const SizedBox(width: 16),
                ElevatedButton(
                  onPressed: onSend,
                  child: const Text('Send'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPidField({
    required String label,
    required TextEditingController controller,
  }) {
    return SizedBox(
      width: 80, // фиксированная ширина, достаточно для "99.99"
      child: TextField(
        controller: controller,
        decoration: InputDecoration(
          labelText: label,
          border: const OutlineInputBorder(),
          isDense: true,
          contentPadding: const EdgeInsets.symmetric(
            vertical: 8,
            horizontal: 8,
          ),
        ),
        keyboardType:
            const TextInputType.numberWithOptions(decimal: true),
        maxLength: 7,
        maxLengthEnforcement: MaxLengthEnforcement.enforced,
        style: const TextStyle(fontSize: 14),
      ),
    );
  }
}

